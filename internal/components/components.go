// Package components defines the core interfaces for the IPRL probing system.
// It provides abstractions for the three main component types: Probing Agents (PA),
// Probing Directive Generators (PDG), and the Probing Orchestrator (PO).
package components

import (
	"context"
	"io"

	pb "iprl-demo/internal/gen/proto"
)

// Runner represents a component that can be started and run with a context.
// The Run method should block until the context is cancelled or an error occurs.
type Runner interface {
	Run(ctx context.Context) error
}

// MetaManager provides generic accessors for a component's specification and status.
// Spec defines the component's configuration (typically immutable after registration).
// Status represents the component's current runtime state (mutable, updated by orchestrator).
type MetaManager[Spec, Status any] interface {
	// GetSpec returns the component's specification.
	GetSpec() Spec

	// SetSpec updates the component's specification.
	SetSpec(Spec)

	// GetStatus returns the component's current status.
	GetStatus() Status

	// SetStatus updates the component's status, typically called when
	// the orchestrator pushes new configuration (e.g., rate limits).
	SetStatus(Status)
}

// AgentManager defines the interface for a Probing Agent (PA).
// A Probing Agent receives probing directives from the orchestrator,
// executes network probes, and returns forwarding information elements.
type AgentManager interface {
	Runner

	MetaManager[*pb.ProbingAgentSpec, *pb.ProbingAgentStatus]
}

// GeneratorManager defines the interface for a Probing Directive Generator (PDG).
// A PDG generates probing directives based on its configuration and streams
// them to the orchestrator for distribution to agents.
type GeneratorManager interface {
	Runner

	MetaManager[*pb.ProbingDirectiveGeneratorSpec, *pb.ProbingDirectiveGeneratorStatus]
}

// OrchestratorManager defines the interface for the Probing Orchestrator (PO).
// The orchestrator is the central coordinator that:
//   - Manages registration and lifecycle of agents and generators
//   - Routes probing directives from generators to appropriate agents
//   - Collects forwarding information elements from agents
//   - Maintains and distributes cluster status to all components
type OrchestratorManager interface {
	Runner

	MetaManager[*pb.ProbingOrchestratorSpec, *pb.ProbingOrchestratorStatus]

	// EnqueueDirective adds a probing directive to the distribution queue.
	// Called by generators to submit directives for routing to agents.
	EnqueueDirective(ctx context.Context, directive *pb.ProbingDirective)

	// EnqueueElement adds a forwarding information element to the collection queue.
	// Called by agents to submit probe results.
	EnqueueElement(ctx context.Context, element *pb.ForwardingInfoElement)
}

// Pusher exposes a write-only channel used to push items into a component.
// The returned channel is owned by the callee; callers must not close it.
// Implementations may apply backpressure by blocking on sends.
type Pusher[T any] interface {
	// PushChannel returns a channel on which items can be sent.
	PushChannel() chan<- T
}

// Puller exposes a read-only channel used to pull items from a component.
// The returned channel is owned by the callee; callers must not close it.
// The channel may be closed by the implementation to signal termination.
type Puller[T any] interface {
	// PullChannel returns a channel from which items can be received.
	PullChannel() <-chan T
}

// Prober represents a component that consumes probing directives and
// produces forwarding information elements.
// It acts as a bridge between directive distribution and probe execution.
type Prober interface {
	// Run starts the prober’s main execution loop and blocks until
	// the context is cancelled or an unrecoverable error occurs.
	Runner

	// PushChannel is used to receive probing directives to execute.
	Pusher[*pb.ProbingDirective]

	// PullChannel is used to emit forwarding information elements
	// generated by executed probes.
	Puller[*pb.ForwardingInfoElement]

	// Close releases all resources held by the prober and initiates shutdown.
	// Close must be idempotent and must not block indefinitely.
	// After Close is called, no further values will be emitted.
	io.Closer
}

// DirectiveGenerator represents a component that produces probing directives.
// It encapsulates the logic for deciding *what* to probe and *when*.
type DirectiveGenerator interface {
	// Run starts the generator’s directive production loop and blocks
	// until the context is cancelled or an unrecoverable error occurs.
	Runner

	// PullChannel streams generated probing directives to downstream consumers
	// (typically the orchestrator).
	Puller[*pb.ProbingDirective]

	// Close releases all resources held by the generator and initiates shutdown.
	// Close must be idempotent.
	io.Closer
}
