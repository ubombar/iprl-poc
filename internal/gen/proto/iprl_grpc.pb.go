// proto/iprl.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.31.1
// source: iprl.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PAService_Probe_FullMethodName  = "/iprl.PAService/Probe"
	PAService_Notify_FullMethodName = "/iprl.PAService/Notify"
)

// PAServiceClient is the client API for PAService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PAServiceClient interface {
	// Probing Orchestrator calls this to send directives, PA streams back results
	Probe(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ProbingDirective, ForwardingInfoElement], error)
	// Probing Orchestrator calls this to notify of cluster changes
	Notify(ctx context.Context, in *ClusterStatus, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type pAServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPAServiceClient(cc grpc.ClientConnInterface) PAServiceClient {
	return &pAServiceClient{cc}
}

func (c *pAServiceClient) Probe(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ProbingDirective, ForwardingInfoElement], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &PAService_ServiceDesc.Streams[0], PAService_Probe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ProbingDirective, ForwardingInfoElement]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PAService_ProbeClient = grpc.BidiStreamingClient[ProbingDirective, ForwardingInfoElement]

func (c *pAServiceClient) Notify(ctx context.Context, in *ClusterStatus, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PAService_Notify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PAServiceServer is the server API for PAService service.
// All implementations must embed UnimplementedPAServiceServer
// for forward compatibility.
type PAServiceServer interface {
	// Probing Orchestrator calls this to send directives, PA streams back results
	Probe(grpc.BidiStreamingServer[ProbingDirective, ForwardingInfoElement]) error
	// Probing Orchestrator calls this to notify of cluster changes
	Notify(context.Context, *ClusterStatus) (*emptypb.Empty, error)
	mustEmbedUnimplementedPAServiceServer()
}

// UnimplementedPAServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPAServiceServer struct{}

func (UnimplementedPAServiceServer) Probe(grpc.BidiStreamingServer[ProbingDirective, ForwardingInfoElement]) error {
	return status.Error(codes.Unimplemented, "method Probe not implemented")
}
func (UnimplementedPAServiceServer) Notify(context.Context, *ClusterStatus) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedPAServiceServer) mustEmbedUnimplementedPAServiceServer() {}
func (UnimplementedPAServiceServer) testEmbeddedByValue()                   {}

// UnsafePAServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PAServiceServer will
// result in compilation errors.
type UnsafePAServiceServer interface {
	mustEmbedUnimplementedPAServiceServer()
}

func RegisterPAServiceServer(s grpc.ServiceRegistrar, srv PAServiceServer) {
	// If the following call panics, it indicates UnimplementedPAServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PAService_ServiceDesc, srv)
}

func _PAService_Probe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PAServiceServer).Probe(&grpc.GenericServerStream[ProbingDirective, ForwardingInfoElement]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PAService_ProbeServer = grpc.BidiStreamingServer[ProbingDirective, ForwardingInfoElement]

func _PAService_Notify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PAServiceServer).Notify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PAService_Notify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PAServiceServer).Notify(ctx, req.(*ClusterStatus))
	}
	return interceptor(ctx, in, info, handler)
}

// PAService_ServiceDesc is the grpc.ServiceDesc for PAService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PAService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iprl.PAService",
	HandlerType: (*PAServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Notify",
			Handler:    _PAService_Notify_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Probe",
			Handler:       _PAService_Probe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "iprl.proto",
}

const (
	PDGService_Notify_FullMethodName = "/iprl.PDGService/Notify"
)

// PDGServiceClient is the client API for PDGService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PDGServiceClient interface {
	// Probing Orchestrator calls this to notify of cluster changes
	Notify(ctx context.Context, in *ClusterStatus, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type pDGServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPDGServiceClient(cc grpc.ClientConnInterface) PDGServiceClient {
	return &pDGServiceClient{cc}
}

func (c *pDGServiceClient) Notify(ctx context.Context, in *ClusterStatus, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PDGService_Notify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PDGServiceServer is the server API for PDGService service.
// All implementations must embed UnimplementedPDGServiceServer
// for forward compatibility.
type PDGServiceServer interface {
	// Probing Orchestrator calls this to notify of cluster changes
	Notify(context.Context, *ClusterStatus) (*emptypb.Empty, error)
	mustEmbedUnimplementedPDGServiceServer()
}

// UnimplementedPDGServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPDGServiceServer struct{}

func (UnimplementedPDGServiceServer) Notify(context.Context, *ClusterStatus) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedPDGServiceServer) mustEmbedUnimplementedPDGServiceServer() {}
func (UnimplementedPDGServiceServer) testEmbeddedByValue()                    {}

// UnsafePDGServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PDGServiceServer will
// result in compilation errors.
type UnsafePDGServiceServer interface {
	mustEmbedUnimplementedPDGServiceServer()
}

func RegisterPDGServiceServer(s grpc.ServiceRegistrar, srv PDGServiceServer) {
	// If the following call panics, it indicates UnimplementedPDGServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PDGService_ServiceDesc, srv)
}

func _PDGService_Notify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PDGServiceServer).Notify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PDGService_Notify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PDGServiceServer).Notify(ctx, req.(*ClusterStatus))
	}
	return interceptor(ctx, in, info, handler)
}

// PDGService_ServiceDesc is the grpc.ServiceDesc for PDGService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PDGService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iprl.PDGService",
	HandlerType: (*PDGServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Notify",
			Handler:    _PDGService_Notify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "iprl.proto",
}

const (
	POService_RegisterProbingAgent_FullMethodName                = "/iprl.POService/RegisterProbingAgent"
	POService_UnregisterProbingAgent_FullMethodName              = "/iprl.POService/UnregisterProbingAgent"
	POService_RegisterProbingDirectiveGenerator_FullMethodName   = "/iprl.POService/RegisterProbingDirectiveGenerator"
	POService_UnregisterProbingDirectiveGenerator_FullMethodName = "/iprl.POService/UnregisterProbingDirectiveGenerator"
	POService_GetClusterStatus_FullMethodName                    = "/iprl.POService/GetClusterStatus"
	POService_EnqueueDirective_FullMethodName                    = "/iprl.POService/EnqueueDirective"
	POService_EnqueueForwardingInfoElement_FullMethodName        = "/iprl.POService/EnqueueForwardingInfoElement"
)

// POServiceClient is the client API for POService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type POServiceClient interface {
	// Probing Agent calls this to register itself
	RegisterProbingAgent(ctx context.Context, in *ProbingAgent, opts ...grpc.CallOption) (*RegisterProbingAgentResponse, error)
	// Probing Agent calls this to unregister itself
	UnregisterProbingAgent(ctx context.Context, in *UnregistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Probing Directive Generator calls this to register itself
	RegisterProbingDirectiveGenerator(ctx context.Context, in *ProbingDirectiveGenerator, opts ...grpc.CallOption) (*RegisterProbingDirectiveGeneratorResponse, error)
	// Probing Directive Generator calls this to unregister itself
	UnregisterProbingDirectiveGenerator(ctx context.Context, in *UnregistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Anyone can call this to get the current status of the cluster
	GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error)
	// Probing Directive Generator calls this to send probing directives
	EnqueueDirective(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ProbingDirective, emptypb.Empty], error)
	// Probing Agent calls this to send results back
	EnqueueForwardingInfoElement(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ForwardingInfoElement, emptypb.Empty], error)
}

type pOServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPOServiceClient(cc grpc.ClientConnInterface) POServiceClient {
	return &pOServiceClient{cc}
}

func (c *pOServiceClient) RegisterProbingAgent(ctx context.Context, in *ProbingAgent, opts ...grpc.CallOption) (*RegisterProbingAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterProbingAgentResponse)
	err := c.cc.Invoke(ctx, POService_RegisterProbingAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pOServiceClient) UnregisterProbingAgent(ctx context.Context, in *UnregistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, POService_UnregisterProbingAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pOServiceClient) RegisterProbingDirectiveGenerator(ctx context.Context, in *ProbingDirectiveGenerator, opts ...grpc.CallOption) (*RegisterProbingDirectiveGeneratorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterProbingDirectiveGeneratorResponse)
	err := c.cc.Invoke(ctx, POService_RegisterProbingDirectiveGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pOServiceClient) UnregisterProbingDirectiveGenerator(ctx context.Context, in *UnregistrationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, POService_UnregisterProbingDirectiveGenerator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pOServiceClient) GetClusterStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClusterStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStatus)
	err := c.cc.Invoke(ctx, POService_GetClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pOServiceClient) EnqueueDirective(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ProbingDirective, emptypb.Empty], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &POService_ServiceDesc.Streams[0], POService_EnqueueDirective_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ProbingDirective, emptypb.Empty]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type POService_EnqueueDirectiveClient = grpc.ClientStreamingClient[ProbingDirective, emptypb.Empty]

func (c *pOServiceClient) EnqueueForwardingInfoElement(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ForwardingInfoElement, emptypb.Empty], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &POService_ServiceDesc.Streams[1], POService_EnqueueForwardingInfoElement_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ForwardingInfoElement, emptypb.Empty]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type POService_EnqueueForwardingInfoElementClient = grpc.ClientStreamingClient[ForwardingInfoElement, emptypb.Empty]

// POServiceServer is the server API for POService service.
// All implementations must embed UnimplementedPOServiceServer
// for forward compatibility.
type POServiceServer interface {
	// Probing Agent calls this to register itself
	RegisterProbingAgent(context.Context, *ProbingAgent) (*RegisterProbingAgentResponse, error)
	// Probing Agent calls this to unregister itself
	UnregisterProbingAgent(context.Context, *UnregistrationRequest) (*emptypb.Empty, error)
	// Probing Directive Generator calls this to register itself
	RegisterProbingDirectiveGenerator(context.Context, *ProbingDirectiveGenerator) (*RegisterProbingDirectiveGeneratorResponse, error)
	// Probing Directive Generator calls this to unregister itself
	UnregisterProbingDirectiveGenerator(context.Context, *UnregistrationRequest) (*emptypb.Empty, error)
	// Anyone can call this to get the current status of the cluster
	GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error)
	// Probing Directive Generator calls this to send probing directives
	EnqueueDirective(grpc.ClientStreamingServer[ProbingDirective, emptypb.Empty]) error
	// Probing Agent calls this to send results back
	EnqueueForwardingInfoElement(grpc.ClientStreamingServer[ForwardingInfoElement, emptypb.Empty]) error
	mustEmbedUnimplementedPOServiceServer()
}

// UnimplementedPOServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPOServiceServer struct{}

func (UnimplementedPOServiceServer) RegisterProbingAgent(context.Context, *ProbingAgent) (*RegisterProbingAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterProbingAgent not implemented")
}
func (UnimplementedPOServiceServer) UnregisterProbingAgent(context.Context, *UnregistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UnregisterProbingAgent not implemented")
}
func (UnimplementedPOServiceServer) RegisterProbingDirectiveGenerator(context.Context, *ProbingDirectiveGenerator) (*RegisterProbingDirectiveGeneratorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterProbingDirectiveGenerator not implemented")
}
func (UnimplementedPOServiceServer) UnregisterProbingDirectiveGenerator(context.Context, *UnregistrationRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UnregisterProbingDirectiveGenerator not implemented")
}
func (UnimplementedPOServiceServer) GetClusterStatus(context.Context, *emptypb.Empty) (*ClusterStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterStatus not implemented")
}
func (UnimplementedPOServiceServer) EnqueueDirective(grpc.ClientStreamingServer[ProbingDirective, emptypb.Empty]) error {
	return status.Error(codes.Unimplemented, "method EnqueueDirective not implemented")
}
func (UnimplementedPOServiceServer) EnqueueForwardingInfoElement(grpc.ClientStreamingServer[ForwardingInfoElement, emptypb.Empty]) error {
	return status.Error(codes.Unimplemented, "method EnqueueForwardingInfoElement not implemented")
}
func (UnimplementedPOServiceServer) mustEmbedUnimplementedPOServiceServer() {}
func (UnimplementedPOServiceServer) testEmbeddedByValue()                   {}

// UnsafePOServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to POServiceServer will
// result in compilation errors.
type UnsafePOServiceServer interface {
	mustEmbedUnimplementedPOServiceServer()
}

func RegisterPOServiceServer(s grpc.ServiceRegistrar, srv POServiceServer) {
	// If the following call panics, it indicates UnimplementedPOServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&POService_ServiceDesc, srv)
}

func _POService_RegisterProbingAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProbingAgent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(POServiceServer).RegisterProbingAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: POService_RegisterProbingAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(POServiceServer).RegisterProbingAgent(ctx, req.(*ProbingAgent))
	}
	return interceptor(ctx, in, info, handler)
}

func _POService_UnregisterProbingAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(POServiceServer).UnregisterProbingAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: POService_UnregisterProbingAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(POServiceServer).UnregisterProbingAgent(ctx, req.(*UnregistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _POService_RegisterProbingDirectiveGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProbingDirectiveGenerator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(POServiceServer).RegisterProbingDirectiveGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: POService_RegisterProbingDirectiveGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(POServiceServer).RegisterProbingDirectiveGenerator(ctx, req.(*ProbingDirectiveGenerator))
	}
	return interceptor(ctx, in, info, handler)
}

func _POService_UnregisterProbingDirectiveGenerator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(POServiceServer).UnregisterProbingDirectiveGenerator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: POService_UnregisterProbingDirectiveGenerator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(POServiceServer).UnregisterProbingDirectiveGenerator(ctx, req.(*UnregistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _POService_GetClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(POServiceServer).GetClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: POService_GetClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(POServiceServer).GetClusterStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _POService_EnqueueDirective_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(POServiceServer).EnqueueDirective(&grpc.GenericServerStream[ProbingDirective, emptypb.Empty]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type POService_EnqueueDirectiveServer = grpc.ClientStreamingServer[ProbingDirective, emptypb.Empty]

func _POService_EnqueueForwardingInfoElement_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(POServiceServer).EnqueueForwardingInfoElement(&grpc.GenericServerStream[ForwardingInfoElement, emptypb.Empty]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type POService_EnqueueForwardingInfoElementServer = grpc.ClientStreamingServer[ForwardingInfoElement, emptypb.Empty]

// POService_ServiceDesc is the grpc.ServiceDesc for POService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var POService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "iprl.POService",
	HandlerType: (*POServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterProbingAgent",
			Handler:    _POService_RegisterProbingAgent_Handler,
		},
		{
			MethodName: "UnregisterProbingAgent",
			Handler:    _POService_UnregisterProbingAgent_Handler,
		},
		{
			MethodName: "RegisterProbingDirectiveGenerator",
			Handler:    _POService_RegisterProbingDirectiveGenerator_Handler,
		},
		{
			MethodName: "UnregisterProbingDirectiveGenerator",
			Handler:    _POService_UnregisterProbingDirectiveGenerator_Handler,
		},
		{
			MethodName: "GetClusterStatus",
			Handler:    _POService_GetClusterStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EnqueueDirective",
			Handler:       _POService_EnqueueDirective_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "EnqueueForwardingInfoElement",
			Handler:       _POService_EnqueueForwardingInfoElement_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "iprl.proto",
}
